package PantryPal.server.handlers;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.util.ArrayList;

import java.util.Arrays;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;

import PantryPal.server.interfaces.IGPTManager;
import PantryPal.server.interfaces.IWhisperManager;
import PantryPal.server.models.*;

public class RecordingHandler implements HttpHandler {

    RecipeManager recipeManager;
    IWhisperManager whisperManager;
    IGPTManager gptManager;

    /**
     * Constructor for the Recording Handler class, assigns the managers to be used during handling
     * @param recipeManager manger for recipes
     * @param whisperManager manager class for whisper api calls
     * @param gptManager manager class for chat-gpt api calls
     */
    public RecordingHandler (RecipeManager recipeManager, IWhisperManager whisperManager, IGPTManager gptManager){
        this.recipeManager = recipeManager;
        this.whisperManager = whisperManager;
        this.gptManager = gptManager;
    }
    
    /**
     * Exports the recording from an input stream to a file
     * SOURCE: https://stackoverflow.com/a/37885810
     * SOURCE: https://piazza.com/class/lmy9axhgowe53s/post/325
     * @param input InputStream of the recording
     * @return If export was successful
     * @throws IOException
     */
    public boolean exportRecording(InputStream input) throws IOException {

        String CRLF = "\r\n";
        int fileSize = 0;
        
        String FILE_TO_RECEIVED = "recording_server.wav";
        File f = new File(FILE_TO_RECEIVED);

        if (!f.exists()) {
            f.createNewFile();
        }
        
        String nextLine = readLine(input, CRLF);

        while (!nextLine.equals("")){
            if (nextLine.startsWith("Content-Length:")) {
                fileSize = 
                    Integer.parseInt(
                        nextLine.replaceAll(" ", "").substring(
                            "Content-Length:".length()
                        )
                    );
            }
            nextLine = readLine(input, CRLF);
        }

        byte[] midFileByteArray = new byte[fileSize];
        int readOffset = 0;
        while (readOffset < fileSize) {
            int bytesRead = input.read(midFileByteArray, readOffset, fileSize);
            readOffset += bytesRead;
        }
        
        BufferedOutputStream bos = 
            new BufferedOutputStream(new FileOutputStream(FILE_TO_RECEIVED));
        
        bos.write(midFileByteArray, 0, fileSize);
        bos.flush();
        bos.close();
        return true;
    }

    /**
     * Method for handling the request from the HTTP exchange 
     * @param exchange HTTP exchange containing the request
     * @throws IOException
     */
    @Override
    public void handle(HttpExchange exchange) throws IOException {

        URI uri = exchange.getRequestURI();
        String query = uri.getRawQuery();            
        String paramString = query.substring(query.indexOf("=") + 1);
        ArrayList<String> params = new ArrayList<String>(Arrays.asList(paramString.split(",")));
        String processString = params.get(0);
        // process should either be mealtype or ingredients
        
        InputStream input = exchange.getRequestBody();

        exportRecording(input);
        String response = "";
        
        if (processString.equals("mealtype")){
            response = handleMealTypeSubmission();
        } else if (processString.equals("ingredients")){
            response = handleIngredientsSubmission(params.get(1));
        } else {
            System.out.println("bad");
        }

        System.out.println("RESPONSE:\n"+response);
        exchange.sendResponseHeaders(200, response.length());
        OutputStream outStream = exchange.getResponseBody();
        outStream.write(response.getBytes());
        outStream.close();
    }

    /**
     * Uses the transcript generated by Whisper to determine the meal type for the
     * recipe to be generated.
     * @return selected meal type
     */
    public String handleMealTypeSubmission(){
        whisperManager.setFilePath("recording_server.wav");

        String output = "";
        try{
            output = whisperManager.generateTranscript();

        } catch (Exception e){
            System.out.println(e);
        }

        Boolean hasBreakfast = output.toLowerCase().contains("breakfast");
        Boolean hasLunch = output.toLowerCase().contains("lunch");
        Boolean hasDinner = output.toLowerCase().contains("dinner");

        if (hasBreakfast){
            return "breakfast";
        } else if (hasLunch) {
            return "lunch";
        } else if (hasDinner) {
            return "dinner";
        } 
        return "";
    }

    /**
     * function for submitting for the ingredients type for http request
     * @param mealtype
     * @return
     */
    public String handleIngredientsSubmission(String mealtype){
        String gptOutput = "";
        try {
            whisperManager.setFilePath("recording_server.wav");
            String output = whisperManager.generateTranscript();
            gptOutput = gptManager.analyze(output, mealtype);
        } catch (Exception e){
            
        }
        String genRecipe = gptOutput;//recipeManager.parseRecipe(gptOutput).getJSONString();
        return genRecipe;
    }
    
    
    /**
     * This method will read a line from the given InputStream using the provided
     * lineSeperator string
     * SOURCE: https://stackoverflow.com/a/37885810
     * SOURCE: https://piazza.com/class/lmy9axhgowe53s/post/325
     * @param is InputStream object
     * @param lineSeparator string to split lines on 
     * @return The line read
     * @throws IOException
     */    
    private static String readLine(InputStream is, String lineSeparator) 
    throws IOException {

        int off = 0, i = 0;
        byte[] separator = lineSeparator.getBytes("UTF-8");
        byte[] lineBytes = new byte[1024];
        
        while (is.available() > 0) {
            int nextByte = is.read();
            if (nextByte < -1) {
                throw new IOException(
                    "Reached end of stream while reading the current line!");
            }
            
            lineBytes[i] = (byte) nextByte;
            if (lineBytes[i++] == separator[off++]) {
                if (off == separator.length) {
                    return new String(
                        lineBytes, 0, i-separator.length, "UTF-8");
                }
            }
            else {
                off = 0;
            }
            
            if (i == lineBytes.length) {
                throw new IOException("Maximum line length exceeded: " + i);
            }
        }
        
        throw new IOException(
            "Reached end of stream while reading the current line!");       
    }
}
